# Malware Techniques

## Lecture Notes: Malware Persistence Mechanisms

### What is a DLL?

<figure><img src=".gitbook/assets/{D6F77710-DC78-4C9B-8BE3-5E7D7924797A}.png" alt=""><figcaption><p>calling and utilizing a DLL</p></figcaption></figure>

* dynamic link library
* a library that contains code and data that can be used by more than one program at the same time- Microsoft
* PE file format
  * one bit is different than EXEs (is\_DLL)
* used to export/import libraries and functions for programs to extend their capabilities
* can attach DLLs to processes and threads
  * can also specify what happens when detaching the DLLS from processes and threads
  * DLL\_PROCESS\_ATTACH: what happens when you attach the DLL to the process
* when a DLL is called specifically (as seen in the above image), it allows for our PE tools (like CFF Explorer) to see the imports named properly

### DLL Injection

* normal
  * Windows loader is used to load DLL and its imports
    * [LoadLibrary()](pe-files.md#packed-executables)
      * Kernel32.dll
  * DLL is officially registered and can be seen easily in Process Explorer/Process Hacker
  * threat actors often don't use this because they are pulling libraries from elsewhere (the malicious EXE being used, a remote location, etc.)
  * ex. you load kernel32.dll into memory with LoadLibrary-> you want to call CreateProcess -> you use GetProcAddress to locate where CreateProcess is in memory
* API(s) used
  * [GetProcAddress](pe-files.md#packed-executables) -> find LoadLibrary's address
    * Kernel32.dll
  * VirtualAlloc(Ex)
    * locates some space (in an amount defined by the dev) in memory to allocate for the process
    * VirtualAllocEx is used for remote processes (ex. process A is loading process B)
  * WriteProcessMemory
  * CreateRemoteThread
    * addr of LoadLibrary
    * Path2DLL
    * used to trigger remote library
* example of benign use: browser extensions being injected to add functionality to your browser

### How Injection Works

<figure><img src=".gitbook/assets/{BC7BABCC-BFE5-4774-B254-5EC435F1C731}.png" alt=""><figcaption></figcaption></figure>

* getting the handle of a process is how you access it
  * OpenProcess opens access to the process (not running it)
* allocates memory space in the victim process with VirtualAllocEx() and gets privileges
  * if trying to access a victim process with higher processes, it may be denied
    * must have the same or higher privileges
* WriteProcessMemory() with DLL path to copy the malicious DLL into the victim process (can also load the full DLL)
* execute the malicious DLL in the victim process with CreateRemoteThread()

#### Steps

* step 1: open handle to target process
* step 2: allocate memory to store file path (SeDebug privilege required)
* step 3: find kernel32.LoadLibrary function address
* step 4: use one of several remote thread creation APIs (like CreateRemoteThreadEx) to load DLL into target process's memory space
  * creates new thread and executes LoadLibrary to load DLL
* DLL now runs in target process
