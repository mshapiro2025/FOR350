# Malware Techniques

## Lecture Notes: Malware Persistence Mechanisms

### What is a DLL?

<figure><img src=".gitbook/assets/{D6F77710-DC78-4C9B-8BE3-5E7D7924797A}.png" alt=""><figcaption><p>calling and utilizing a DLL</p></figcaption></figure>

* dynamic link library
* a library that contains code and data that can be used by more than one program at the same time- Microsoft
* PE file format
  * one bit is different than EXEs (is\_DLL)
* used to export/import libraries and functions for programs to extend their capabilities
* can attach DLLs to processes and threads
  * can also specify what happens when detaching the DLLS from processes and threads
  * DLL\_PROCESS\_ATTACH: what happens when you attach the DLL to the process
* when a DLL is called specifically (as seen in the above image), it allows for our PE tools (like CFF Explorer) to see the imports named properly

### DLL Injection

* normal
  * Windows loader is used to load DLL and its imports
    * [LoadLibrary()](pe-files.md#packed-executables)
      * Kernel32.dll
  * DLL is officially registered and can be seen easily in Process Explorer/Process Hacker
  * threat actors often don't use this because they are pulling libraries from elsewhere (the malicious EXE being used, a remote location, etc.)
  * ex. you load kernel32.dll into memory with LoadLibrary-> you want to call CreateProcess -> you use GetProcAddress to locate where CreateProcess is in memory
* API(s) used
  * [GetProcAddress](pe-files.md#packed-executables) -> find LoadLibrary's address
    * Kernel32.dll
  * VirtualAlloc(Ex)
    * locates some space (in an amount defined by the dev) in memory to allocate for the process
    * VirtualAllocEx is used for remote processes (ex. process A is loading process B)
    * usually uses the Windows Memory Manager to find unallocated space, which means that there won't be a conflict between legitimate code in memory and the injected code
  * WriteProcessMemory
  * CreateRemoteThread
    * addr of LoadLibrary
    * Path2DLL
    * used to trigger remote library
* example of benign use: browser extensions being injected to add functionality to your browser

#### How Injection Works

<figure><img src=".gitbook/assets/{16BF981C-06CA-4B50-9C75-D9BC28D9F1D4}.png" alt=""><figcaption></figcaption></figure>

* getting the handle of a process is how you access it
  * OpenProcess opens access to the process (not running it)
* allocates memory space in the victim process with VirtualAllocEx() and gets privileges
  * if trying to access a victim process with higher processes, it may be denied
    * must have the same or higher privileges
* WriteProcessMemory() with DLL path to copy the malicious DLL into the victim process (can also load the full DLL)
* execute the malicious DLL in the victim process with CreateRemoteThread()

#### Steps

* step 1: open handle to target process
* step 2: allocate memory to store file path (SeDebug privilege required)
* step 3: find kernel32.LoadLibrary function address
* step 4: use one of several remote thread creation APIs (like CreateRemoteThreadEx) to load DLL into target process's memory space
  * creates new thread and executes LoadLibrary to load DLL
* DLL now runs in target process

### Persistence and Avoiding Detection

* threat actors may target explorer.exe and svchost.exe
  * must have high enough perms
* self-injection
  * the process itself injects itself with other code and overwrites

### Common Autostart Locations

* several locations in registry
  * many locations
    * SYSINTERNALS Autoruns tool lists most of them
  * most common:
    * HKLM or HKCU
      * \Software\Microsoft\Windows\CurrentVersion\Run or RunOnce
* on file system&#x20;
  * \[Profile]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup

### Installing as a Service

* create new service that looks legitimate
  * Svchost1 or svhost or bluetoothd or upnp or dnsservice
* modify ImagePath or ServiceDLL of unused service
  * services like "Distributed Link Tracking" which are not essential or likely to be noticed when disabled

### DLL Search Order

<figure><img src=".gitbook/assets/{A8D5A94A-E551-46B3-AB55-58A9A7FE8D18}.png" alt=""><figcaption></figcaption></figure>

* Windows uses the Search Order list to locate and load a DLL, which threat actors take advantage of by hijacking
  * looks in memory
  * occurs when only the DLL name is called in WriteProcessMemory, not the DLL path or full DLL
* location info:
  * application's directory: the application may not be located in a default directory- if it's located in the Downloads folder, that will be the application's directory
  * current directory: ex. if an application is run from the Desktop and it exists in the Downloads folder, Desktop will be the current directory
  * %PATH% is an environment variable that defines several directories- allows you to call files from various locations without having to specify the file path (ex. why you can type cmd.exe from anywhere and run it, even though it exists in C:\Windows\System32)
* list -> HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
  * defined by Microsoft as system and application critical
    * ex. kernel32.dll, advapi32.dll
* can be hijacked by placing malicious DLLs in the right location
  * placing a Shell extension DLL (loaded by explorer.exe) in the same folder- C:\Windows
    * Windows will search EXE's folder first, then go look at System32

<figure><img src=".gitbook/assets/{ED806284-0F1E-4B14-9B25-95622C0476C5}.png" alt=""><figcaption></figcaption></figure>

### Proxy DLL



<figure><img src=".gitbook/assets/{238E7C68-D581-4BF7-8D41-447139C14504}.png" alt=""><figcaption></figcaption></figure>

### Hijacking Extension Handlers

<figure><img src=".gitbook/assets/{DACCC699-21E7-4743-8D8C-6EF31D7E1E2E}.png" alt=""><figcaption></figcaption></figure>

* change what happens when a file of a specific extension is double-clicked
  * ex. text files are opened in Notepad by default -> change that to a malicious application
* registry modification in HKU
  * doesn't require admin
* can modify for everyone in HKEY\_CLASSES\_ROOT

### Reflective DLL Injection

* reflective injection means:
  * Windows Loader is not used
    * uses its own loader
  * since Windows does not load it, there are no formal traces seen
    * injected into the memory of the process
* needs to fix two important things (the loader has to rebuild them):
  * relocation table
  * import table
* example of APIs used:
  * VirtualAlloc
  * WriteProcessMemory
  * CreateRemoteThread
* must load the DLL into memory and have the structures to reference info
  * entry point, reference tables, etc.
  * normally the Windows Loader handles this
* additional malware techniques are built on reflective DLL injection
  * still requires the loader, relocation table, import table, etc.
* VMMap shows different allocated memory for processes- image, mapped file, private data, etc.
  * if anything has been defined by the EXE, it will probably be in private data
  * after injection, there will likely be new private data regions with execute permissions
    * memory regions with read/write/execute are red flags
      * Outlook and Office are the two common programs that use it to some extent
  * Ctrl + T shows the text/strings- can potentially see injected DLLs referenced in the executable memory areas
* System Informer
  * can click on processes -> Properties -> Modules
    * can see DLLs- won't see injected DLL
    * go to Memory -> filter and search for memory regions with RWX -> double click and can see what's loaded
      * MZ (4D 5A) header indicates an EXE or DLL
      * still won't see the DLL name listed
* the only way to catch this is an EDR or AV that is scanning memory or performing a memory dump and doing memory forensics
* any memory region with RWX (read, write, execute perms) is WACK
* if a PE file is loaded in memory and not backed by a file on disk, that's WACK
  * in System Informer, you would see the file it is backed by in the "Use" column, so if that column is blank, WACK
* can run DLLs natively in Windows with rundll32
  * threat actors can use this to run DLLs

{% embed url="https://github.com/stephenfewer/ReflectiveDLLInjection" %}

### Process Hollowing

* a process is a box
  * each process has handles pointing to different resources
    * threads, image, security context, etc.
* another injection method of executing arbitrary code in the address space of a separate live process
* occurs by un-mapping (hollowing out) the legitimate code from memory of the target process and overwriting the memory space of the target process (ex. svchost.exe) with a malicious executable
* goal is to hide the presence of a process and evade process-based defenses
* people looking at the process would see the usual box/process, but hidden inside that box is a pointer to the malicious executable
* MITRE Att\&ck Technique T1055.012
* program is created in a suspended state, then its pointer to its legitimate image is changed to point to something malicious
* hollowing steps
  * create innocent process, started in a suspended state
  * image is hollowed out/removed (entry point is still pointing to the same location)
  * image is replaced with malware (entry point is now pointing to the malware)
* hollowing steps as APIs
  * CreateProcess("\[process name"...CREATE\_SUSPENDED...)
  * NtUnmapViewOfSection()
  * VirtualAllocEx()
  * WriteProcessMemory(...\[malware.exe]...)
  * SetThreadContext()
  * ResumeThread()
* with relocation, the PE sections are looped over with WriteProcessMemory, then the image is relocated
* EDRs tend to catch processes that start in a suspended state

### Others

* modify userinit key
  * HLKM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit\userinit.exe -> malware.exe
* register DLL to start with Winlogon
* scheduled tasks
* Powershell scripts
  * Poweliks, Kovtar, etc.
* WMI- Windows Management Interface
* fileless malware
  * runs in memory, not on disk
  * achieves persistence by copying themselves into a different form NOT on disk- ex. Windows registry

## Lab Notes: Call for Help

* change default web browser to Google Chrome
* sample deletes running instances of tools like Wireshark, ProcMon, and ProcExp
* three options:
  * use new tools
  * copy tools to new file locations and rename them
  * patching
* patching
  * open sample with debugger
* API Monitor
  * API Filter Window
    * Find
      * can search for functions as seen in CFF Explorer
  * can save settings so you don't have to reconfigure
  * Monitor New Process -> select process file
    * won't accurately pick up elevation if it was run as admin, since API Monitor is already admin

## Lab Notes: Reflective DLL Injection

```
rundll32 [DLL name] [function in DLL]
```

* can call main function in any DLL with dllmain

## Additional Notes

* malware that interacts with existing processes needs to use CreateToolhelp32Snapshot because it takes snapshots of running processes
  * start with Process32First, then Process32Next
    * starts at the first process- if not the right one, moves on
* letters in function names
  * A in a function name indicates ACSII/ANSI
    * 1 byte
  * W in a function name indicates wide characters
    * multiple bytes
  * neither in a function name means that the system will use whichever is needed
* CreateToolhelp32Snapshot
  * handle value is then used when Process32First is called right after
* Process32First/Next
  * can expand LPPROCESSENTRY to see process name
* CreateFileA creating a DLL- why is a file creating a library in C:\Windows\System32? a legitimate program would most likely create a program in Program Files
* SetTime function- can copy time from a legitimate file and change the file timestamps to that same timestamp to have it blend in
* obfuscation: if there is another super common value in the file that isn't 0, the most common value was originally 0 and was XORed by its new value
  * ex. the most common value is 24- that value was 0 and was XORed by 24 to become 24
  * can use 010 Editor for Binary XOR with hex and 24 to deobfuscate
  * ex. dropped file was obfuscated- can deobfuscate and find proper file headers
